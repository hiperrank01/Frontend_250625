# Next.js App Router .cursorrules (한국어 + 영어 혼합)

## 프로젝트 아키텍처

- **타입**: Turborepo Monorepo 구조
- **메인 앱들**:
  - recatch-nextjs: Next.js 14 App Router (메인 앱)
  - recatch-embed: React Embed App (임베드 위젯)
  - recatch-tracker: Tracking Script (추적 스크립트)
  - recatch-nextjs-e2e: E2E Testing (Playwright)
  - recatch-nextjs-dev-proxy: Development Proxy Server
  - recatch-embed-analyzer: Embed Analysis Tool
- **아키텍처**: Domain Driven Design (DDD) - presentation 레거시 분리 작업 진행중
- **언어**: TypeScript
- **스타일링**: tailwindcss 
- **상태 관리**:
  - 서버: React Query (TanStack Query)
  - 클라이언트: Context + useState (현재), Zustand (사용중)
- **테스팅**:
  - 단위 테스트: Vitest
  - E2E 테스트: Playwright (별도 앱)

## Next.js App Router 모범 사례

- 서버 컴포넌트(server components)와 서버 액션(server actions) 점진적 도입
- 클라이언트 컴포넌트가 주로 사용되는 현재 상황에서 점진적 서버 컴포넌트 전환
- Dependency Injection: shared DI(서버+클라이언트)와 클라이언트 전용 DI 구분
- App Router 파일 기반 라우팅 시스템 완전 활용
- 공통 레이아웃은 layout.tsx 사용
- 로딩 상태는 loading.tsx 구현
- 에러 처리는 error.tsx 사용
- 별도 API 서버와의 통신 최적화 (route handlers는 필요시에만)
- SEO 최적화를 위해 metadata API 사용
- 적절한 스트리밍과 Suspense 경계 구현

## 도메인 주도 설계(DDD) 규칙

- 도메인 로직과 인프라 관심사 분리
- 명확한 도메인 모델과 값 객체 사용
- 데이터 접근을 위한 Repository 패턴 구현
- 도메인 간 느슨한 결합 유지 (의존성 정리 진행중)
- 도메인별 로직은 domains/ 디렉토리에 구현
- **레거시**: 도메인 내 presentation 레이어 분리 작업 진행중 (React 의존성 제거)
- **신규**: 새로운 도메인 추가 시 presentation 레이어 분리된 구조로 생성

## 클린 아키텍처 규칙

- **의존성 규칙**: data → domain ← presentation (domain이 중심)
- **플로우**: UI -> (필요시) Hook -> React Query -> Repository(converter) -> API
- **domains/\*/src/data**: DTO 정의, API 응답을 도메인 모델로 변환하는 Converter
- **domains/\*/src/domain**: Repository 인터페이스, 도메인 모델, 비즈니스 로직
- **domains/\*/src/presentation**: 도메인별 Components, Hooks (분리 작업 진행중)
- **packages/\***: 공통 유틸리티 패키지들 (design-system, date-utils, string-utils 등)
- Repository 인터페이스는 domain에, 구현체는 사용하는 앱에 배치 (ex. recatch-nextjs)
- Converter는 외부 API 의존성을 domain 레이어로부터 격리
- 각 레이어는 명확한 책임과 경계를 가짐
- 비즈니스 로직은 policy 함수(정책/검증) 또는 helper 함수(계산/변환)에서 관리
- 공통 유틸리티는 packages/ 디렉토리에 배치하여 재사용성 증대

## TypeScript 모범 사례

- 항상 엄격한 TypeScript 설정 사용 (strict: true)
- Domain Model과 DTO 타입 명확히 분리
- Converter 함수를 통한 DTO → Domain Model 변환
- Zod 스키마 활용 검토 중 (런타임 검증 + 타입 추론)
- 상태 관리에 discriminated unions 사용
- Result<T, E> 패턴으로 에러 처리 타입 안전성 확보
- 재사용 가능한 컴포넌트에 제네릭 타입 사용
- **type vs interface 기준**: Union/Intersection은 type, 확장 가능한 구조는 interface
- 적절한 곳에 const assertions 사용
- **null 사용 금지**: undefined로 통일 관리 및 optional chaining 적극 활용 (useRef 예외)
- 타입 어설션(as) 사용 최소화 - 적절한 타입 정의로 해결

## 코드 구조화

- 파일과 폴더명은 kebab-case 사용
- React 컴포넌트는 PascalCase 사용
- 함수와 변수는 camelCase 사용
- **recatch-nextjs**: 페이지별 \_components, \_hooks, \_queries 폴더 구조 활용
- **domains**: 각 도메인별 data(dto, converter), domain(Repository, model), presentation(components, hooks) 레이어 구조
- 컴포넌트는 복잡한 로직 없이 UI에만 집중
- 비즈니스 로직은 hook으로 분리
- 정책/검증 로직은 policy 함수로 분리하여 테스트 코드 보장
- 계산/변환 로직은 helper 함수로 분리하여 테스트 코드 보장
- 순수 함수는 utils로 분리하여 테스트 코드 보장
- **이벤트 핸들러**: handle + subject + event 형태로 명명, props 전달시 on + subject + event
- 컴포넌트 props interface는 Props로 작명
- 감싸는 styled-component는 Wrapper로 작명
- **컴포넌트 파일 순서**: 1) interface/types, 2) 컴포넌트 함수, 3) styled-components
- 적절한 에러 경계(Error Boundaries) 구현

## 스타일링 가이드라인

- Ant Design 컴포넌트를 기본으로 사용 (디자이너 적용 여부에 따라)
- 커스텀 스타일과 레이아웃은 styled-components 사용
- **design-system 패키지**: 리캐치 디자인 시스템으로 선정된 컴포넌트만 추가 (table, badge 등)
- 중복 컴포넌트라고 해서 무조건 design-system에 추가하지 않음
- 일관된 spacing과 sizing 스케일 사용
- styled-components 성능 이슈 인지 (향후 마이그레이션 고려)
- 색상과 타이포그래피는 디자인 시스템 토큰 따르기

## 성능 최적화

- 이미지 최적화를 위해 Next.js Image 컴포넌트 사용
- 적절한 lazy loading 구현
- 비용이 많이 드는 컴포넌트는 React.memo 사용
- 적절한 코드 분할 구현
- 적절한 곳에 서버 사이드 렌더링 사용
- Tree shaking으로 번들 크기 최적화
- 적절한 캐싱 전략 사용

### 모노레포 특화 성능 최적화

- 각 앱별 번들 크기 모니터링 및 최적화
- 불필요한 의존성 설치 방지 (workspace별 분리)
- Turbo 캐싱 전략 최적화로 빌드 시간 단축
- 공통 패키지 변경 시 영향받는 앱만 재빌드
- 패키지 간 중복 코드 최소화
- 각 워크스페이스별 개별 최적화 전략 적용

## 테스팅 가이드라인

### 필수 테스트 작성 대상

- **Policy 함수**: 반드시 테스트 코드 작성 (정책/검증 로직 보장)
- **Helper 함수**: 반드시 테스트 코드 작성 (계산/변환 로직 보장)
- **Repository**: 반드시 테스트 코드 작성 (데이터 접근 로직 보장)
- **Converter**: 반드시 테스트 코드 작성 (데이터 변환 로직 보장)
- **Utils**: 반드시 테스트 코드 작성 (순수 함수 보장)

### 권장 테스트 작성 대상

- **Hook**: 테스트 코드 작성 권장 (웬만하면 작성)

### 테스트 제외 대상

- **Query Hook**: 테스트 코드 작성하지 않음 (React Query 기반)

### 테스트 파일 위치 및 명명 규칙

- **테스트 파일 경로**: tests/ 안에 실제 구현체와 동일한 경로로 생성
  - 예: `domains/*/src/data/converters/foo.ts` → `domains/*/src/tests/data/converters/foo.test.ts`
  - 예: `apps/*/data/repositoryImpls/Bar.ts` → `apps/*/tests/data/repositoryImpls/Bar.test.ts`
- **Repository 구현체**: 도메인 패키지가 아닌 사용하는 앱에서 구현 (ex. recatch-nextjs)
- **테스트 코드 형식**: `// Given`, `// When`, `// Then` 형식으로 작성 (첫 글자 대문자)
- **테스트 작성 방식**: 메소드 호출 여부보다는 실제 데이터 반환 여부에 집중하여 테스트
- **expected 변수**: 예상 결과값은 미리 Given 섹션에 선언

### 테스트 프레임워크

- **단위 테스트**: Vitest 사용
- **E2E 테스트**: Playwright 사용 (별도 앱)
- **컴포넌트 테스트**: React Testing Library 사용
- 테스트에서 외부 의존성 Mock 처리
- 복잡한 객체는 test data builders 사용
- 적절한 테스트 정리 구현

## 보안 모범 사례

- 클라이언트와 서버 모두에서 입력값 검증
- 민감한 데이터는 환경변수 사용
- 적절한 인증과 인가 구현
- 프로덕션에서 HTTPS 사용
- XSS 방지를 위한 사용자 입력 sanitization
- 적절한 CORS 정책 구현
- 보안 헤더 사용

## 코드 품질

- 명확한 변수명으로 자기 설명적인 코드 작성
- 함수명과 변수명은 의도를 명확히 표현 (Clean Code 원칙)
- 한 함수는 한 가지 일만 담당 (Single Responsibility Principle)
- Public API에는 JSDoc 주석 추가
- 일관된 포맷팅 (Prettier) 사용
- ESLint 규칙 엄격히 준수 (커스텀 recatch-nextjs-app-dir 플러그인 포함)
- **Next.js App Router**: 직계 조상 디렉토리 또는 \_접두사 디렉토리에서만 import
- 적절한 에러 처리 구현
- **TBD(Trunk-Based Development)** 방식 지향
- PR 단위 작게 유지 (300줄 이내 권장)
- 가능한 한 순수 함수 사용
- 깊은 중첩 피하기 (최대 3레벨)

## 모노레포 전용 규칙

- 서버-클라이언트 통합 모노레포 구조로 풀스택 개발 지원
- **의존성 분산**: root package.json에서 각 앱/패키지/도메인으로 의존성 분산 진행중
- **앱별 의존성 분리**: recatch-nextjs(Next.js 특화), recatch-embed(React 특화), 향후 recatch-server(서버 특화)
- 패키지 간 의존성 동기화 유지 (pnpm workspace 활용)
- 내부 패키지는 workspace:\* references 사용
- 적절한 빌드 순서 의존성 구현 (turbo.json 활용)
- 공통 설정 파일 공유 (tsconfig, eslint, prettier)
- **일관된 패키지 네이밍**: @recatch/[package-name]
- 순환 의존성 방지: dpdm 도구로 정기적 검사
- **서버-클라이언트 코드 공유**: 도메인 로직과 타입 정의만 공유, UI 로직은 분리
- 환경별 설정 분리: 개발/스테이징/프로덕션 환경 독립적 관리
- 빌드 최적화: turbo 캐싱과 증분 빌드 활용
- 패키지 간 API 계약: 명확한 인터페이스 정의로 결합도 최소화
- 의존성 충돌 방지: 각 워크스페이스별 필요한 의존성만 설치
- 배포 패키지는 적절한 버전 관리 사용 (semantic versioning)
- 개발 환경 일관성: 모든 개발자가 동일한 pnpm 버전과 설정 사용
- 패키지 간 의존성 문서화: 각 패키지의 README에 의존성 관계 명시

## 개발 워크플로우

- 새로운 개발을 위한 feature branch 생성
- 커밋 메시지는 conventional commits 사용
- 커밋 전 테스트 실행
- 적절한 코드 리뷰 구현
- 더 나은 성능을 위한 증분 빌드 사용
- 패키지는 집중되고 응집력 있게 유지

### AI 도구 학습을 위한 문서화 프로세스

- 각 패키지/도메인별 README.md 작성 (목적, 사용법, API)
- 아키텍처 결정 문서화 (ADR: Architecture Decision Records)
- 복잡한 비즈니스 로직에 JSDoc 주석 추가
- 트러블슈팅 가이드 유지보수
- 환경 설정 및 배포 가이드 최신화
- 의존성 관계 다이어그램 업데이트
- 컨벤션 변경 시 .cursorrules 파일 동기화

## AI 어시스턴트 지침

이 코드베이스를 도울 때:

1. **아키텍처 인식**: 항상 DDD 아키텍처와 모노레포 구조 고려
2. **Next.js 모범 사례**: App Router 컨벤션을 따르고 기본적으로 서버 컴포넌트 사용
3. **TypeScript 우선**: 적절한 인터페이스로 강력한 타입 솔루션 제공
4. **도메인 경계**: 도메인 경계를 존중하고 도메인 간 결합 피하기
5. **성능**: 제안사항의 성능 영향 고려
6. **테스팅**: 변경사항에 대한 적절한 테스트 전략 제안
7. **보안**: 항상 보안 영향 고려
8. **일관성**: 코드베이스의 기존 패턴 따르기
9. **문서화**: 복잡한 로직에 대한 명확한 설명 제공
10. **확장성**: 애플리케이션과 함께 변경사항이 어떻게 확장될지 고려

### 변경사항을 만들 때:

- 아키텍처 결정에 대한 이유 설명
- 코드 품질과 성능 개선 제안
- 잠재적 이슈나 엣지 케이스 식별
- 테스트 권장사항 제공
- 기존 파일 명명 및 구조화 컨벤션 따르기

**한국어로 설명하되, 기술 용어는 영어 원문을 병기하여 정확성을 높여주세요.**
